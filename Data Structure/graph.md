# Graph(그래프)

## 개념 및 용어 정리
단순히 노드(N, node)와 그 노드를 연결하는 간선(E, edge)을 하나로 모아 놓은 자료 구조로 연결되어있는 객체간의 관계를 표현 할 수 있는 자료구조이다.

### 👩‍💻 그래프와 트리의 차이점
<img src="https://gmlwjd9405.github.io/images/data-structure-graph/graph-vs-tree.png">

### 그래프에서 쓰이는 용어들

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcjbjPd%2FbtqKgF6OzSD%2FU0a7BKCpfJlhx1iJzwsEy1%2Fimg.png" width="200px">

* 정점(vertice) : 노드라고도 하며 데이터가 저장됨(이미지의 0, 1, 2, 3)
* 간선(edge): 링크라고도 부르며 노드간의 관계를 나타낸다
* 인접 정점(adjacent vertex) : 간선에 의해 연결된 정점(이미지의 0과 1은 인접 정점)
* 단순 경로(simple-path): 경로 중 반복되는 정점이 없는것(**단순**이라는 말의 의미는 경로나 사이클에서 `같은 정점을 두 번 이상 방문하지 않음`을 의미)
* 차수(degree): (무방향)그래프에서 하나의 정점에 인접한 정점의 수 (정점 0의 차수는 3)
* 진출 차수(out-degree) : 방향그래프에서 사용되는 용어로 한 노드에서 외부로 향하는 간선의 수
* 진입차수(in-degree) : 방향그래프에서 사용되는 용어로 외부 노드에서 들어오는 간선의 수를 의미

## 그래프의 종류
#### 1.무방향 그래프 VS 방향 그래프
<img src="https://t1.daumcdn.net/cfile/tistory/99CF983D5C6D5A6B0A">

* 무방향 그래프 : 간선을 통해서 양 방향으로 갈 수 있다(정점 A와 정점 B를 연결하는 간선은 (A, B)와 같이 정점의 쌍으로 표현하며 (A, B)는 (B, A) 동일한 의미다)


* 방향 그래프 : 간선에 방향성이 존재하는 그래프(A -> B로만 갈 수 있는 간선은 <A, B>로 표시한다)

#### 2. 가중치 그래프
간선에 비용이나 가중치가 할당된 그래프<br>
**네트워크(network)** 라고도 한다

#### 3. 완전 그래프
그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프
* 무방향 완전 그래프(정점 수: n이면 간선의 수: n * (n-1) / 2)

## 그래프 구현 방법
### 1.인접행렬 방식 -> 2차원 배열로 그래프의 연결관계를 표현하는 방식

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F7RFhy%2FbtqKkOhoYiE%2FSE3IQP2q0g3xd34EQZkjM1%2Fimg.png">

2차원 배열에 각 정점 연결된 형태를 기록하는 방식이다. <br>
연결이 되어있지 않은 정점의 경우 *무한의 비용*이라고 작성한다.<br>
(실제로 정답이 될 수 없는 큰 값중에서 999999999,928374728 등의 값으로 초기화 하는 경우가 많다)

```python
# 정점 1 -(7)- 정점 0 -(5)- 정점 2

INF = 9999999999 #무한의 비용 선언

#2차원 리스트를 이용해 인접 행렬 표현
graph = [
	[0, 7, 5],
	[7, 0, INF],
	[5, INF, 0]
]

print(graph)
# [[0,7,5], [7,0,999999999], [5,999999999,0]]
```
* 장점 : 2차원의 배열에 모든 간선정보가 있기때문에 배열의 위치를 확인하면 두 정점에 대한 연결 정보 조회시 O(1)의 시간복잡도면 가능하다
* 단점 : 모든 정점에 대한 정보를 기입하기 때문에 O(n²)의 시간복잡도를 가진다. 2차원 배열이 필요하기때문에 필요이상의 공간이 낭비될 수 있다

### 2. 인접 리스트 방식 -> 연결된 정점에 대한 정보를 차례대로 연결해서 저장
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FNlh1G%2FbtqKicb2Wub%2FsHWVSS6bn2FZdijEJVR2r1%2Fimg.png">

각각의 정점에 인접한 정점들을 리스트로 표시한 것이다.<br>
배열과 각 배열의 인덱스마다 존재하는 또 다른 리스트(연결리스트, 배열 등)를 이용해 인접리스트를 표현한다

```python
#Row(행)이 3개인 2차원 리스트로 인접 리스트 표현
graph = [[] for _ in range(3)]

#노드0에 연결된 노드 정보 저장(노드, 거리)
graph[0].append((1, 7))
graph[0].append((2, 5))

#노드 1에 연결된 노드정보 저장(노드, 거리)
graph[1].append((0, 7))

#노드 2에 연결된 노드정보 저장(노드, 거리)
graph[2].append((0, 5))

print(graph)
# [[(1,7),(2,5)],[(0,7)],[(0,5)]
```

### 두방식의 차이점

인접행렬방식은 노드개수가 많을수록 메모리가 불필요하게 낭비된다. but 특정한 인접 노드를 순회해야하는 경우, 인접리스트 방식이 인접 행렬 방식에 비해 메모리 공간의 낭비가 적다. 

인접리스트방식은 연결된 정보만을 저장하기때문에, 메모리를 효율적으로 사용, but 특정 두노드가 연결되어있는지 정보를 얻는 속도가 느리다(하나하나 데이터를 확인해야해서)
