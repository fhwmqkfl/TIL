# 웹 통신의 흐름
> `www.google.com`를 주소창에 치면 무슨 일이 일어날까?
___
## 1. 브라우저 URL 파싱

![img](https://user-images.githubusercontent.com/75003424/124287483-0671f200-db8b-11eb-9498-e17442d62bb7.png)

입력받은 URL의 구조를 해석한다.
* 어떤 **프로토콜**을 통해 URL을 요청할 것인지,
* 어떤 **URL**로 요청할 것인지
* 어떤 **포트**로 요청할 것인지 -> HTTP = 80 포트 , HTTPS = 443 포트를 디폴트로 한다.

## 2. HSTS 목록 조회 
_HSTS(HTTP Strict transport security)_ :  HTTP를 허용하지 않고 `HTTPS`를 사용하는 연결만 허용하는 기능이다.

* 브라우저는 HTTPS로만 연결되도록 요청한 웹사이트의 목록인 HSTS (HTTP Strict Transport Security)" 리스트를 미리 준비하고, 요청이 들어오면 이 리스트안에 있는지 확인한다
* HSTS목록에 존재한다면, 브라우저는 요청을 HTTP 대신 HTTPS로 보낸다(HTTP로 요청해도 HTTPS반환)

## 3. URL을 IP주소로 변환
컴퓨터끼리는 www.google.com 이라는 주소로 통신할 수 없다. <br>
이 주소를 컴퓨터가 읽을 수 있도록 **IP주소로 변환**해야 통신이 가능하다.

도메인 주소를 IP주소로 변환해주는 `DNS (Domain Name System)서버`에 요쳥하여 해당 URL을 IP주소로 변환한다.

> **IP란?** <br>
인터넷에 연결되어 있는 장치(컴퓨터, 스마트폰, 타블릿, 서버 등등)들이 서로 인식하고 통신을 하기위해 존재하는 고유한 주소 <br>
예) 115.68.24.88, 192.168.0.1

> **도메인(domain)이란?**<br>
ip는 사람이 이해하고 기억하기 어렵기 때문에 이를 위해서 각 ip에 이름을 부여할 수 있게 했는데, 이것을 도메인이라고 한다.

브라우저는 이때 HTTP Request Message를 만든다. 

## 4. 라우터를 통해 해당 서버의 게이트웨이까지 이동한다.
네트워크 장비인 **라우터**의 라우팅을 이용해 이루어짐

## 5. ARP를 통해 IP주소를 MAC주소로 변환
실질적인 통신을 하기 위해서는 논리 주소인 IP주소를 물리 주소인 `MAC주소`로 변환해야 한다.

이를 위해 해당 네트워크 내에서 **ARP**를 `브로드 캐스팅`하는데,
해당 IP주소를 가지고 있는 노드는 자신의 MAC 주소를 응답합니다.

> **ARP (Address Resolution Protocol)**
    해당 IP를 그 IP주소에 맞는 물리적인 주소 즉, MAC주소를 가지고 오는 프로토콜이다.

> **브로드캐스팅(broadcasting)**
    송신 호스트가 전송한 데이터가 네트워크에 연결된 모든 호스트에 전송되는 방식을 의미한다.
    ![img](https://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Broadcast.svg/250px-Broadcast.svg.png)

## 6. 대상 서버와 TCP 소켓 연결
이제 대상 서버와 통신하기 위해 `TCP 소켓 연결`을 진행한다<br>
소켓 연결은 `3-way-handshake`라는 과정을 통해 이루어진다<br>


### 👉 3-way-handshake
<img src="https://feel5ny.github.io/images/2018/01/handshake.jpg">

1. 연결을 하기 전 :  클라이언트는 Closed 상태이고, 서버는 요청을 기다리고 있는 LISTEN 상태
2. 클라이언트에 --> 서버 : 연결을 요청하는 **SYN** 데이터를 전송
3. 서버 --> 클라이언트 : 서버가 SYN을 받으면 그 응답으로, 클라이언트에게 받았던 SYN에 ACK데이터를 추가해 데이터를 보낸다. 클라이언트에게 "잘받았으니 포트 열어달라는 신호보냄"<br> 
(동시에 서버는 `LISTEN 상태`에서 상대방의 응답을 기다리는 `SYN_RCV 상태`로 변경됨)
4. 클라이언트에 --> 서버 : 서버로부터 ACK + SYN 데이터를 받으면, 클라이언트는 **포트를 열고** 이에 대한 확인으로 서버에 ACK 데이터를 보냄<br> (그러면서 클라이언트는 `Closed 상태`에서 `ESTABLISHED 상태`로 바뀜
5. 서버 : ACK 데이터를 받은 서버도 `ESTBALISHED 상태`로 변경되면서, 클라이언트와 서버는 연결이 됨

> **HTTPS 요청의 경우 암호화 통신에 필요한 과정(TLS 핸드쉐이킹)이 추가된다**
### 👉 TLS-handshake
TLS(Transport Layer Security)는 HTTP 방식 뿐만아니라 TCP통신을 하는 FTP같은 프로토콜에도 적용될 수 있다.
1.  클라이언트 --> 서버 : 클라이언트는 **TLS버전, 암호 알고리즘 목록 그리고 사용 가능한 압축 방식**을 `ClientHello 메시지`에 담아 서버로 전송
2. 서버 --> 클라이언트 : 서버는 클라이언트에게 **TLS 버전, 선택한 암호 알고리즘, 선택한 압축 방식 그리고 CA (Certificate Authority) 가 사인한 서버의 공개 인증서**를 `ServerHello 메시지`에 담아 답장한다.<br>
(인증서에는 대칭키가 생성되기 전까지 handshake 과정을 암호화하는 데에 쓸 공개키가 들어있음)
3. 클라이언트 : 서버가 보낸 인증서가 유효한지를, 신뢰할 수 있는 CA 목록을 통해 확인한다. CA를 통해 신뢰성이 확보되면, 클라이언트는 의사 난수 바이트를 생성하고, 이 난수를 서버의 공개키로 **암호화**한다.<br>
(난수 바이트는 대칭키를 정할 때 사용)
4. 서버 : 받은 난수 바이트를 자기 개인키로 **복호화**해 대칭 마스터키 생성에 활용
5. 클라이언트 : `Finished 메시지`를 서버로 보내고, 지금까지의 교환 내역을 해시한 값을 대칭키로 암호화하여 담는다
6. 서버 :  스스로도 해시를 생성해 클라이언트에서 도착한 값과 일치하는지 확인하고, 일치하면, 서버도 클라이언트와 동일하게 대칭키를 통해 암호화한 `Finished 메시지`를 클라이언트에 전송한다.
7. 이제 TLS 세션이 대칭키로 암호화된 어플리케이션 (HTTP) 데이터를 전송할수 있게 된다

### 👉 Https요청의 소켓 연결 과정
<img width="471" alt="스크린샷 2022-09-08 오후 7 51 08" src="https://user-images.githubusercontent.com/71719160/189104232-1d8a01d6-c17b-46c3-b884-27b13f027f76.png">

## 7. HTTP(HTTPS) 프로토콜로 요청, 응답
이제 연결이 확정되었으니 드디어 해당 페이지 www.google.com를 달라고 서버에게 요청을 보냄

요청을 받은 서버는 수락할 수 있는 요청인지 검사하고, 이 요청에 대한 응답을 생성하여 브라우저에게 전달

## 8. 브라우저에서 응답을 해석한다.
이를 브라우저에서 해석하여 화면에 보여줌

## 간단하게 요약해보면?

> URL 파싱 <br>
 → 도메인 주소를 IP주소로 변환 (DNS 서버에 요청을보냄)<br>
 → 라우터를 통해 IP주소로 해당 서버 게이트웨이 까지 이동 <br>
 → ARP 프로토콜로 IP주소를 MAC주소로 변환 <br>
 → 변환된 MAC주소를 통해 해당 서버와 TCP소켓 연결 (3-way, TLS) <br>
 → 연결을 확정지은 후 서버에 요청을 보냄 <br>
 → 요청에 대한 응답을 브라우저가 해석하여 랜더링 페이지 출력
