## 1. 운영체제 (Operating System) 란
컴퓨터를 켜면 가장 먼저 만나게 되는 소프트웨어로 윈도우, Mac OS, 유닉스, 리눅스 등이 있다. <br>

(cpu 성능 다운 & 메모리를 적게 사용해 작은 시스템에 내장하도록 만든 임베디드 운영체제도 있음)

> 운영체제는 사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템의 자원을 효율적으로 관리하는 소프트 웨어이다

### 1-1. 운영체제의 필요성
초기 컴퓨터는 정해진 계산 수행이 주목적이라 특별한 사용규칙이 필요하지 않았으나, <br>

기술 성능의 향상 & 여러 작업의 동시 실행이 가능한 컴퓨터 환경이 조성되며 규칙이 필요해짐 -> 이때 등장한게 `운영체제` <br>

운영체제가 있으면 새로운 기능의 추가나 성능의 변경이 가능해 성능 및 효율성의 향상을 꾀할 수 있다. <br>


### 1-2. 운영체제의 역할

1. 자원 관리 : 운영체제는 적당한 순서로 자원을 분배하고 회수하여 자원을 관리

2. 자원 보호 : 비정상적인 작업(셧 다운)으로부터 컴퓨터 자원을 보호함

3. 하드웨어 인터페이스 제공 : 다양한 종류의 하드웨어를 복잡한 과정 없이 사용할 수 있게 해줌

4. 사용자 인터페이스 제공 : GUI(사용자 인터페이스)를 제공하여 사용자가 OS를 좀 더 편리하게 사용하도록 지원<br>
ex) 마우스 이용, 터치스크린
___

## 2. 운영체제의 역사
### 1. 초창기 컴퓨터(1940년대)

최초의 컴퓨터인 `에니악`등장.<br>
진공관이라는 소자를 사용해 진공관의 켜짐 여부로 0,1판단했으며, 18000개의 진공관을 전선으로 연결해 사용했다
> 전선을 연결해 논리회로를 구성하는걸 _하드와이어링 방식_ 이라고 한다.



### 2. 일괄 작업 시스템 (1950년대)

기술발전으로 진공관에서 IC칩으로 이루어지게 됨. <br>

입출력장치로써 천공카드리더와 라인프린터가 존재했다. <br>

천공카드 시스템은 카드에 구멍을 뚫어 이를 컴퓨터에 입력시키는 방식인데, 천공카드 리더를 사용하면 프로그램만 바꾸면 다른 작업도 가능했다



### 3. 대화형 시스템(1960년대 초반)

키보드와 모니터가 등장했으며, 컴퓨터가 사용자의 대화를 통해 작업이 이루어지는 대화형 시스템 개념이 등장했다.

다만 일괄 작업 시스템은 개입이 없어 작업 시간의 예측이 가능했는데, 대화형 시스템은 작업 시간의 예측이 어려웠다.



### 4. 시분할 시스템(1960년대 후반)

비싼 컴퓨터를 한번에 한 작업만 시키는게 아닌, 하나의 cpu에 여러 작업을 동시에 실행시키는 **다중 프로그래밍 기술** 이 개발되었다.

이 다중 프로그래밍 기술은 여러작업이 동시에 실행되는것 처럼 보이는데, 이는 `시간을 분할 하는 방법`때문이다

* 시분할 시스템(다중 작업 시스템)  : 다중 프로그래밍 시스템에서는 cpu사용 시간을 아주 잘게 쪼개어 여러작업에 나누어준다.  <br> cpu사용 시간을 아주 잘게 쪼개 작업들에게 나누어 줌으로써 여러 작업이 동시에 진행되는것 처럼 보이게 된다. <br> -> 여기서 잘게 나뉜 시간 한조각을 _타임슬라이스_ , _타임퀀텀_ 이라고 말한다

* 시분할 시스템의 단점 

    * 여러 작업을 동시에 처리하게 하기위한 추가 작업이 필요하다.

    * 많은 양의 작업이 공존할 경우 중요작업이 일정시간안에 끝나는 것을 보장하지 못한다 <br> -> 미사일발사, 원자력 등 중요한 작업들은 시분할 시스템을 사용하지 않고 특정 시스템에서 일정 시간안에 작업이 처리되도록 보장하는 `실시간 시스템` 을 사용한다



###  👉 다중 사용자 시스템

시분할 시스템은 하나의 컴퓨터에서 여러명이 작업할 수 있는 다중 사용자 시스템을 가능하게 했다. 



### 5. 분산 시스템(1970년대 후반)

인터넷이 등장한 시기이다. <br>

서로 호환되지 않는 방법들을 하나의 프로토콜로 묶었는데, 이때 정리된 TCP/IP 프로토콜도 지금까지 쓰이고 있다 <br>

이전에는 작업을 위해 **메인프레임** 이라는 고가의 대형 컴퓨터를 사용했는데, <br>
개인용 컴퓨터와 인터넷이 보급되며 이 컴퓨터들을 하나로 묶어 대형 컴퓨터에 버금가는 시스템을 만들수 있게 되었다. 

* 분산 시스템  : 네트워크 상에 분산되어있는 여러 컴퓨터들을 하나로 묶어 작업을 처리하고 그 결과를 상호 교환하도록 구성한 시스템

### 6. 클라이언트/서버 시스템(1990년대~현재)

분산시스템은 모든 컴퓨터가 동일한 지위로 만약 한대가 고장나거나 or 추가되면 작업 분배&결과수집이 어려워진다는 단점이 있다. <br>

클라이언트/서버 시스템은 분산시스템의 문제를 해결한 기술로, <br>

모든 컴퓨터가 동일한 것이 아닌 작업을 요청하는 **클라이언트** 와 요청받은 작업을 처리하는 **서버** 의 이중구조로 구성된다<br>

* 단점 : 서버 과부하가 되면 서버가 다운될 수 있다



### 7. P2P시스템(2000년대 초반~현재)

서버의 부하를 줄이는 새로운 시스템으로 P2P(Peer-to-Peer)시스템이 탄생했다. <br>

* peer : 말단 노드를 의미. 여기에서는 사용자의 컴퓨터를 의미한다. 

P2P는 서버를 거치지 않고 사용자와 사용자를 직접 연결한다는 뜻으로 대표적으로 메신저(서버는 사용자인증, 출석만 확인)와 파일공유가 있다.



### 8. 클라우드 컴퓨팅

* 그리드 컴퓨팅 : 필요한 컴퓨팅 자원을 구매하여 사용하는 컴퓨팅 환경을 의미. 

* SaaS(Software as a Service) : 사용자가 필요할 때 소프트웨어 기능을 이용하고 그만큼 비용을 내는 개념

클라우드 컴퓨팅은 그리드 컴퓨팅과 SaaS를 합쳐놓은 개념으로, 언제 어디서나 응용 프로그램과 데이터를 자유롭게 사용할 수 있는 컴퓨팅 환경을 말한다.

___

## 3. 운영체제의 구조
> 운영체제는 크게 **인터페이스**와 **커널**, 두 부분으로 나뉜다
## 💻 커널
<img src="https://velog.velcdn.com/images/moonlt93/post/3a5f634f-7f98-48e9-9248-bb02ad86c1aa/image.png">

커널은 프로세스 관리, 메모리 관리, 저장장치 관리와 같은 운영체제의 핵심적인 기능을 모아놓은 것<br>
커널 내부에는 시스템 호출과 드라이버가 존재한다. 
1. 시스템 호출 : 커널이 자신을 보호하기 위해 만든 인터페이스이다. 커널은 사용자나 프로그램이 자원에 직접 접근하는것을 차단한다.
2. 드라이버 : 커널과 하드웨어 사이의 인터페이스이다. 커널은 입출력의 기본 부분만 제공하는데, 해당 하드웨어의 소프트웨어를 받아 커널이 실행될 때 함께 실행되게 한다.

### 커널의 구성
커널은 아래와 같은 일을 주로 행한다
* 프로세스 관리 : 프로세스에 cpu를 배분하고 작업에 필요한 제반 환경을 제공한다.
* 메모리 관리 : 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간을 제공한다.
* 파일 시스템 관리 : 데이터를 저장하고 접근할 수 있는 인터페이스를 제공한다.
* 입출력 관리 : 필요한 입출력 서비스를 제공한다.
* 프로세스 간 통신 관리 : 공동 작업을 위한 각 프로세스 간 통신환경을 일원한다.

> 커널의 핵심 기능은 유기적으로 복잡하게 엵혀있는데, <br>
> 이 기능을 어떻게 구현하느냐에 따라 단일형, 계층형, 마이크로 구조 터널로 구분한다.

#### 1. 단일형 구조 커널
<img src="https://velog.velcdn.com/images/moonlt93/post/acfd0efb-8e16-4bae-847d-3a9ebf461f83/image.png">

초창기 운영체제 구조로 커널의 핵심 기능을 구현하는 모듈들이 모두 구분없이 하나로 구성되어 있다.
* 장점 : 모듈이 분리되어 있지 않기에 모듈간의 통신 비용이 줄어들어 효율적 운영이 가능한다.
* 단점 
  * 모든 모듈이 하나로 묶여있어 버그나 오류를 처리하기가 어렵다
  * 상호 의존성이 높아 작은 기능상 결함이 시스템 전체로 확장될 수 있음
  * 오늘날의 복잡한 운영체제에 구현하기가 매우 어렵다

#### 2. 계층형 구조 커널
<img src="https://velog.velcdn.com/images/moonlt93/post/16718f5f-7351-4d1d-a7b7-ee983c168337/image.png">

비슷한 기능을 가진 모듈들을 묶어 하나의 계층으로 만들고 계층간의 통신을 통해 운영체제를 구현하는 방식이다.<br>
오늘날의 대부분이 커널로 구성되어있다.
* 장점 : 단일형 구조보다 버그, 오류를 쉽게 처리가능하다
* 단점 
  * 상하관계가 생기기 떄문에 하나의 계층에 이상이 생기면 위,아래 계층에도 영향이 생긴다.
  * 운영체제가 커지고 복잡해지며 커널의 크기가 커지고 하드웨어 용량도 방대해진다

#### 3. 마이크로 구조 커널
<img src="https://velog.velcdn.com/images%2Fchappi%2Fpost%2F1f1463dd-a821-45db-9616-8832e4d4aada%2F4.png" style="width: 70%">

운영체제의 많은 부분을 사용자 영역에 구현해 처리하는 구조이다<br>
기존 단일형 구조 커널에서 핵심 서비스 만을 남겨두고 나머지는 제외하여 가볍게 만든 최소한의 커널이다.<br>
대표적으로 마하가 OS X와 IOS 커널로 사용되어 유명해졌다.


#### 4. 가상 머신
운영체제의 종류가 늘어나며 운영체제끼리도 호환되지 않는 경우가 생겨나기 시작했다 <br>
호환성 문제를 해결한 대표적이 언어가 `JAVA`인데 운영체제위에 가상머신을 만들고 그 위에 응용프로그램이 작동하게 했다