Algorithm
---

## 복잡도(complexity)

### ⏱ 알고리즘의 성능을 나타내는 척도.

시간복잡도와, 공간복잡도 두가지의 개념으로 나뉘며, 복잡도가 낮을수록 좋은 알고리즘이라 생각할수 있음

- 시간 복잡도 : 특정한 크기의 입력에 대하여 알고리즘이 얼마나 오래 걸리는가(연산의 횟수)
- 공간 복잡도 : 특정한 크기의 입력에 대해 알고리즘이 얼마나 많은 메모리를 차지하는가(메모리의 양)

이 둘은 서로 **거래관계(trade-off)**가 성립한다(`메모리소모` <-> `계산의 복잡도`)
> ex) 메모리를 좀더 사용하는 대신 반복되는 연산을 생략하는 `메모이제이션(Memoization)`기법

## 1. 시간 복잡도

알고리즘 테스트 에서의 복잡도가 보통 **시간복잡도**를 의미한다.<br>
자료의 수 n이 증가할 때 시간이 증가하는 대략적인 패턴을 시간 복잡도라는 이름으로 나타내게 된다.<br>
'시간제한'은 코딩테스트에서 작성한 프로그램이 모든 입력을 받아 이를 처리하고 결과를 출력하는데까지 걸리는 시간을 의미함


### 시간 복잡도의 종류
  1. `빅 오(Big-O)` : 가장 빠르게 증가하는 항만을 고려하는 표기법으로 **상한**만을 고려하는 표기법이다. (최악의 경우)
  2. `빅 오메가(Big-Ω)` :  특정 알고리즘의 최선의 시간 복잡도. (최선의 경우)
  3. `빅 세타(Big-θ)` : 평균적인 경우, 딱 맞는 수행 시간. Big-O 와 big-Ω 를 하나로 합쳐 표현한것과 같다.

_여기서 일반적으로 사용하는 표기법은 빅오 표기법으로 TIL에서 적용되는 시간 복잡도는 **빅오 표기법**을 따른다_

### 빅오 표기법의 종류
1. `O(N)` 선형시간

    아래의 예제는 5개의 데이터를 5회 더해준다(N=5).<br> 이 경우의 시간 복잡도는 N에 비례하는 연산을 수행하는 **반복문**이므로 `O(N)`라고 표기한다

    ```python
    array = [1,2,3,4,5] #5개의 데이터(N = 5)
    summary = 0 

    for x in array:
        summary += x

    print(summary) 

    #이경우 시간복잡도는 O(N)
    ```

2. `O(I)` 상수시간

    a값과 b값을 더하는 연산의 경우 변수지정 & print를 무시하고 보면 단순한 더하기 1번뿐. 시간복잡도는 `O(I)`로 표현할 수 있다.

    ```python
    a = 5
    b = 6
    print(a+b)

    #이경우 시간복잡도는 O(I)
    ```

3. `O(N²)` 이차 시간

    ```python
    array = [1,2,3,4,5]
    #5개의 데이터(N=5)

    for i in array:
        for j in array:
            temp = i * j
            print(temp)
    ```

    데이터의개수 array리스트 변수의 길이가 N개일 때, `O(N²)`의 시간 복잡도를 가진다.<br>

### 시간 복잡도 표
알고리즘의 성능은` O(1) > O(logN) > O(N) > O(NlogN) > O(N^2) > ... > O(2^N)` 순으로 나타낼 수 있다.

![big0img](https://user-images.githubusercontent.com/71719160/187076380-20693651-4f0e-41d9-b0f5-50788d8b472c.jpeg)


## 2. 공간 복잡도
### 표현방법  :`빅오(Big-O)` (시간 복잡도와 동일)

시간복잡도에서 1초라는 제한이 있었던 것처럼, 메모리 사용량에도 절대적인 제한이 존재한다. <br>
코딩테스트에서는 메모리 사용량을 128~512MB정도로 제한하는데, 이는 데이터 개수가 1,000만 단위를 넘어가지 않도록 설계해야한다는 것을 의미한다.


<br>

> ### 💡 알고리즘 에서의 중요한 포인트 💡
> 가독성을 해치지 않는 선에서 최대한 복잡도가 낮게 프로그램을 작성해야한다!
