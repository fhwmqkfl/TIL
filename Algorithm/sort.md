# 정렬
## Intro...
컴퓨터 분야에서 중요시되는 문제 가운데 하나로 어떤 데이터들이 주어졌을 때 이를 정해진 순서대로 나열하는 문제이다. <br>
실제 컴퓨터 분야에서 사용하는 데이터의 경우 숫자의 순서나 어휘의 순서대로 정렬한 다음 사용해야 되는 경우가 거의 항상 발생하는데 **이걸 얼마나 효과적으로 해결할 수 있느냐**가 정렬 문제의 핵심이다.

> 데이터를 정렬해야 하는 이유 => `탐색`을 위해서!

## 1.선택 정렬(Selection Sort)
데이터가 무작위로 여러개가 있을때, <br>
이중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고,<br>
그다음 작은 데이터를 선택해 앞에서 두번째 데이터와 바꾸는 과정을 반복한다.
```python
array = [7, 5, 9. 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
	min_index = i # 가장 작은 원소의 인덱스
	for j in range(i + 1, len(array)):
		if array[min_index] > array[j]:
			min_index = j
	array[i], array[min_index] = array[min_index],array[i]

print(array)
```
> **시간복잡도** <br>
>간단히 `O(N²)`라고 표현할 수 있다. 기본정렬 라이브러리를 포함해 다른 알고리즘과 비교했을때 매우 비효율적이다.<br> 다만, 특정한 리스트에서 가장 작은 데이터를 찾는 일이 코딩테스트에서 잦게 나오므로 선택정렬 소스코드 형태에 익숙해질 필요가 있음.

## 2. 삽입정렬(Insertion Sort)
데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하는 알고리즘으로, <br>
실행 시간 측면에서 더 효율적인 알고리즘이다. <br>
삽입정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에 그 앞까지의 데이터는 이미 정렬되어있다고 가정한다. <br>
정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입된다는 점이 특징이다. 
> ⭐️삽입정렬은 두 번째 데이터부터 시작함!(첫 번째 데이터는 그 자체로 정렬이 되어있다고 생각함)
```python
array = [7, 5, 9. 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
	for j in range(i,0,-1) #인덱스 i부터 1까지 감소하며 반복하는 문법작성
		if array[j] > array[j-1]: #한 칸씩 왼쪽으로 이동
			array[j], array[j-1] = array[j-1], array[j]
		else: #자기보다 작은 데이터를 만나면 그위치에서 멈춤
			break
print(array)
```
> 시간복잡도
`O(N²)`가 기본이지만, 혹시 리스트가 거의 정렬되어있는 상태로 입력이 주어질 경우 시간이 `O(N)`이 되는 경우도 있음.

## 3. 퀵 정렬
알고리즘중에 가장 많이 사용되는 알고리즘이다.<br>
대부분의 프로그래밍 언어에더 정렬 라이브러리의 근간이 되는 알고리즘이기도 하다.<br> 
기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다. <br>
* 피벗 : 큰 숫자와, 작은 숫자를 교환할 때 그 기준을 말한다. 큌 정렬 수행전 피벗을 어떻게 할지 반드시 미리 명시해야한다.

### 호어분할방식
리스트에서 첫 번째 데이터를 피벗으로 정한다. 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾는다. 그다음 큰 데이터와 작은 데이터의 위치를 서로 교환해준다.
``` python
array = [7, 5, 9. 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, stop):
	if start >= stop:
		return #원소가 1개인 경우 종료
	pivot = start #피벗은 첫번째 원소
	left = start + 1
	right = end
	while left <= right:
		#피벗보다 큰 데이터 찾을때 까지 반복
		while left <= end and array[left] <= array[pivot]:
			left += 1
		#피벗보다 작은 데이터 찾을 때 까지 반복
		while right > start and array[right] > array[pivot]:
			right -= 1
		if left > right: #엇갈리게 될 경우 작은 데이터와 피벗을 교체
			array[right],array[pivot] = array[pivot],array[right]
		else: #엇갈리지 않은경우 작은데이터와 큰 데이터를 교체
			array[left],array[pivot] = array[pivot], array[left]
	#분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
	quick_sort(array, start, right-1)
	quick_sort(array, right+1, end)

quick_sort(array, 0, len(array)-1)
print(array)

```
### 다른 풀이 방법
파이썬의 장점을 살려 짧게 작성한 퀵코드는 다음과 같다. <br>
전통 퀵 정렬의 분할방식과 조금 다른데, 피벗과 데이터를 비교하는 비교 연산 횟수가 증가하므로 시간면에서는 조금 비효율적일 수 있다.

```python
array = [7, 5, 9. 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array):
	#리스트가 하나 이하의 원소만을 담고 있을 경우 종료
	if len(array) <= 1:
		return array

	pivot = array[0] #피펏은 첫 번째 원소
	tail = array[1:] #피펏을 제외한 리스트
	
	left_side = [x for x in tail if x <= pivot] #분할된 왼쪽부분
	right_side = [x for x in tail if x > pivot] #분할된 오른쪽부분


	#분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬을 수행하고 전체 리스트를 반환
	return quick_sort(left_side) + [pivot] + quick_sort(right_side)

print(quick_sort(array))
```
> 시간 복잡도<br>
선택정렬과 삽입정렬의 시간복잡도는 `O(N²)`이다.<br>
퀵정렬의 `평균 시간 복잡도`는 `O(NlogN)`이다.(매우 빠른편!)<br>
그러나 최악의 경우 `O(N²)`이 된다 → 데이터가 무작위로 되는 경우 매우 빠르지만, 그 반대로 정렬되어있는경우 매우 느리게 동작한다

## 4. 계수 정렬
특정 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다.<br>
모든데이터가 양의 정수이고 개수는 N, 데이터의 최댓값이 K인 경우, 계수정렬은 최악인 경우에도 O(N+K)이다. 계수정렬을 이용할 때에는 '모든 범위를 담을 수 있는 크기의 리스트(배열)을 선언'해야한다.<br>
👉 계수정렬은 간단하고 빠르지만 '데이터의 크기 범위가 제한 되어 정수 형태로 표현할 수 있을 때'만 사용가능하다(무한한 범위는 가지는 실수형데이터의 경우❌)<br>
→ 0~100점 성적데이터를 정렬시 효과적!<br>
👉 또한 큰 데이터와 작은 데이터의 차이가 큰 경우에도 사용하는게 좋지는 않다.
계수 정렬은 일반적으로 별도의 리스트를 선안하고 그 안에 정렬에 대한 정보를 담는다는 특징이 있다.
#### 계수정렬의 예시
    
> 7 5 9 0 3 1 6 2 9 1 4 8 0 5

먼저 가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하나의 리스트를 생성한다.<br>
현재 예시에서는 큰데이터가 9 작은데이터가 0인데 우리는 단순히 크기가 10인 리스트를 선언하면 된다. 

처음에는 리스트의 모든 데이터가 0이 되도록 초기화한다.<br>
그다음 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시키면 계수 정렬이 완료된다. 

```python
#모든 원소의 값이 0보다 크거나 같다고 가정한다.
array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5] 

#모든 범위를 포함하는 리스트 선언(모든 값은 0으로 초기화)
count = [0] * (max(array) + 1)

for i in range(len(array)):
    count[array[i]] += 1 #각 데이터에 해당하는 인덱스의 값 증가

for i in range(len(count)): #리스트에 기록된 정렬 정보 확인
    for j in range(count[i]):
            print(i, end=' ') #띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력

>> 0 0 1 1 2 2 3 4 5 5 6 7 8 9
```
    
> 시간복잡도와 공간복잡도<br>
> * 시간복잡도 : 모든데이터가 양의 정수이고 개수는 N, 데이터의 최댓값이 K인 경우, 계수정렬은 `최악인 경우`에도 `O(N+K)`이다. 데이터가 한정적이면 정말 효과적으로 사용할 수 있다.
> * 공간복잡도 : 데이터가 0, 999999이렇게 두개만 있어도 0으로된 리스트 크기를 100만이 되게 만들어야하는 단점이 존재. 항상사용하는건 아니고, 동일한 값을 데이터가 여러개 등장 할 때 적합하다.
